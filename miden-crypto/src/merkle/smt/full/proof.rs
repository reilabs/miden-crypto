use alloc::string::ToString;

use super::{LeafIndex, SMT_DEPTH, SmtLeaf, SmtProofError, SparseMerklePath, Word};
use crate::{
    EMPTY_WORD,
    merkle::InnerNodeInfo,
    utils::{ByteReader, ByteWriter, Deserializable, DeserializationError, Serializable},
};

/// A proof which can be used to assert membership (or non-membership) of key-value pairs
/// in a [`super::Smt`] (Sparse Merkle Tree).
///
/// The proof consists of a sparse Merkle path and a leaf, which describes the node located at
/// the base of the path.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct SmtProof {
    /// The sparse Merkle path from the leaf to the root.
    path: SparseMerklePath,
    /// The leaf node containing one or more key-value pairs.
    leaf: SmtLeaf,
}

impl SmtProof {
    // CONSTRUCTOR
    // --------------------------------------------------------------------------------------------

    /// Returns a new instance of [`SmtProof`] instantiated from the specified path and leaf.
    ///
    /// # Errors
    /// Returns an error if the path length does not match the expected [`SMT_DEPTH`],
    /// which would make the proof invalid.
    pub fn new(path: SparseMerklePath, leaf: SmtLeaf) -> Result<Self, SmtProofError> {
        let depth = path.depth();
        if depth != SMT_DEPTH {
            return Err(SmtProofError::InvalidMerklePathLength(depth as usize));
        }

        Ok(Self { path, leaf })
    }

    /// Returns a new instance of [`SmtProof`] instantiated from the specified path and leaf.
    ///
    /// The length of the path is not checked. Reserved for internal use.
    pub(in crate::merkle::smt) fn new_unchecked(path: SparseMerklePath, leaf: SmtLeaf) -> Self {
        Self { path, leaf }
    }

    // PROOF VERIFIER
    // --------------------------------------------------------------------------------------------

    /// Returns true if a [`super::Smt`] with the specified root contains the provided
    /// key-value pair.
    ///
    /// This method can also be used to verify non-membership by passing `EMPTY_WORD` as the value,
    /// though [`Self::verify_non_membership()`] is preferred for clarity.
    ///
    /// Note: if false is returned, it could mean either:
    /// - The value at this key doesn't match the provided value, or
    /// - The proof is for a different leaf index than the one the key maps to.
    pub fn verify_membership(&self, key: &Word, value: &Word, root: &Word) -> bool {
        let maybe_value_in_leaf = self.leaf.get_value(key);

        match maybe_value_in_leaf {
            Some(value_in_leaf) => {
                // The value must match for the proof to be valid
                if value_in_leaf != *value {
                    return false;
                }

                // make sure the Merkle path resolves to the correct root
                self.compute_root() == *root
            },
            // If the key maps to a different leaf, the proof cannot verify membership of `value`
            None => false,
        }
    }

    /// Returns true if a [`super::Smt`] with the specified root does not contain any value
    /// for the provided key.
    ///
    /// This is equivalent to calling `verify_membership(key, &EMPTY_WORD, root)`, but makes
    /// the intent clearer and is more convenient to use.
    pub fn verify_non_membership(&self, key: &Word, root: &Word) -> bool {
        self.verify_membership(key, &EMPTY_WORD, root)
    }

    /// Returns true if the provided key maps to the same leaf index as this proof's leaf.
    ///
    /// This can be used to check whether a proof is valid for a given key before calling
    /// [`Self::verify_membership()`] or [`Self::verify_non_membership()`].
    ///
    /// If this returns false, then [`Self::get()`] will return `None`, and both
    /// [`Self::verify_membership()`] and [`Self::verify_non_membership()`] will return false
    /// for this key.
    pub fn is_key_valid(&self, key: &Word) -> bool {
        self.leaf.index() == LeafIndex::<SMT_DEPTH>::from(*key)
    }

    // PUBLIC ACCESSORS
    // --------------------------------------------------------------------------------------------

    /// Returns the value associated with the specific key according to this proof.
    ///
    /// - Returns `None` if the key maps to a different leaf index than this proof's leaf.
    /// - Returns `Some(value)` if the key maps to this leaf index, where `value` is either the
    ///   stored value or `EMPTY_WORD` if the key has no entry in this leaf.
    ///
    /// A key-value pair generated by using this method should pass the `verify_membership()` check.
    pub fn get(&self, key: &Word) -> Option<Word> {
        self.leaf.get_value(key)
    }

    /// Computes the root of a [`super::Smt`] to which this proof resolves.
    pub fn compute_root(&self) -> Word {
        self.path
            .compute_root(self.leaf.index().value(), self.leaf.hash())
            .expect("failed to compute Merkle path root")
    }

    /// Returns the proof's sparse Merkle path.
    pub fn path(&self) -> &SparseMerklePath {
        &self.path
    }

    /// Returns the leaf associated with the proof.
    pub fn leaf(&self) -> &SmtLeaf {
        &self.leaf
    }

    /// Returns an iterator over every inner node of this proof's merkle path.
    pub fn authenticated_nodes(&self) -> impl Iterator<Item = InnerNodeInfo> + '_ {
        self.path
            .authenticated_nodes(self.leaf.index().value(), self.leaf.hash())
            .expect("leaf index is u64 and should be less than 2^SMT_DEPTH")
    }

    /// Consume the proof and returns its parts.
    pub fn into_parts(self) -> (SparseMerklePath, SmtLeaf) {
        (self.path, self.leaf)
    }
}

impl Serializable for SmtProof {
    fn write_into<W: ByteWriter>(&self, target: &mut W) {
        self.path.write_into(target);
        self.leaf.write_into(target);
    }
}

impl Deserializable for SmtProof {
    fn read_from<R: ByteReader>(source: &mut R) -> Result<Self, DeserializationError> {
        let path = SparseMerklePath::read_from(source)?;
        let leaf = SmtLeaf::read_from(source)?;

        Self::new(path, leaf).map_err(|err| DeserializationError::InvalidValue(err.to_string()))
    }
}
